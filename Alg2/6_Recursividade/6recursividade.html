<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Resumo de Recursividade</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 0;
            color: #333;
            background-color: #f5f5f5;
        }

        .container {
            width: 90%;
            max-width: 800px;
            margin: 20px auto;
            padding: 20px;
            background-color: #ffffff;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }

        h1, h2, h3, h4 {
            color: #2c3e50;
            border-bottom: 2px solid #e74c3c;
            padding-bottom: 5px;
        }

        h1 {
            font-size: 2em;
        }

        h2 {
            font-size: 1.5em;
            margin-top: 1.2em;
        }

        h3 {
            font-size: 1.2em;
            margin-top: 1em;
            color: #e74c3c;
        }

        p, ul, ol, pre {
            margin: 15px 0;
        }

        ul, ol {
            padding-left: 20px;
        }

        li {
            margin-bottom: 8px;
        }

        pre {
            background-color: #f0f0f0;
            padding: 15px;
            border-radius: 5px;
            font-size: 1em;
            overflow-x: auto;
            border-left: 4px solid #0073e6;
        }

        code {
            color: #e74c3c;
            font-family: Consolas, monospace;
        }
    </style>
</head>
<body>

    <div class="container">
        <h1>Algoritmo II - 6 Recursividade</h1>

        <h2>1. Conceito de Recursividade</h2>
        <p>Recursividade é a capacidade de uma função de chamar a si mesma. Esse conceito é útil para simplificar certos tipos de problemas em algoritmos, oferecendo soluções mais elegantes e abstratas. Em programação, a recursividade é utilizada principalmente para problemas que envolvem repetição de processos.</p>
        <p><strong>Exemplo Visual</strong>: Pense em uma imagem dentro de outra imagem que se repete indefinidamente; essa é uma representação visual de recursividade.</p>

        <h2>2. Criando Algoritmos Recursivos</h2>
        <p>Para implementar algoritmos recursivos, dois pontos são essenciais:</p>
        <ul>
            <li><strong>Condição de Parada</strong>: Toda função recursiva precisa de uma condição para interromper a recursão, evitando loops infinitos.</li>
            <li><strong>Uso Adequado</strong>: A recursão consome mais recursos de máquina e memória, portanto, é recomendável usá-la em problemas naturalmente definidos de maneira recursiva.</li>
        </ul>

        <h3>Exemplo Clássico: Cálculo do Fatorial</h3>
        <p>O fatorial de um número (representado por <code>n!</code>) é a multiplicação de todos os números de 1 até n. Exemplo:</p>
        <p><code>5! = 5 * 4 * 3 * 2 * 1 = 120</code></p>

        <p>A definição recursiva do fatorial é:</p>
        <ul>
            <li>Se <code>n = 0</code>, então <code>fatorial(n) = 1</code>.</li>
            <li>Se <code>n &gt; 0</code>, então <code>fatorial(n) = n * fatorial(n - 1)</code>.</li>
        </ul>

        <h4>Implementação do Fatorial com Estrutura de Repetição</h4>
        <pre><code>
algoritmo "Fatorial_Loop"
funcao FATORIAL(N : inteiro) : inteiro
var
    resp, i : inteiro
inicio
    resp <- 1
    i <- N
    enquanto (i > 0) faca
        resp <- resp * i
        i <- i - 1
    fimenquanto
    retorne(resp)
fim
        </code></pre>

        <h4>Implementação do Fatorial com Recursão</h4>
        <pre><code>
algoritmo "Fatorial_Recursivo"
funcao FATORIAL(N : inteiro) : inteiro
var
    resp : inteiro
inicio
    se (N > 0) entao
        resp <- N * FATORIAL(N - 1)
    senao
        resp <- 1
    fimse
    retorne(resp)
fim
        </code></pre>

        <h2>3. Funcionamento da Recursão</h2>
        <p>Para entender a recursão, visualize cada chamada recursiva como um novo nível, onde cada função espera a resposta da função chamada antes dela. Esse processo é como uma pilha, onde a última função chamada é a primeira a ser resolvida.</p>

        <p><strong>Exemplo de chamada recursiva para <code>FATORIAL(5)</code>:</strong></p>
        <ol>
            <li><code>FATORIAL(5)</code> chama <code>FATORIAL(4)</code></li>
            <li><code>FATORIAL(4)</code> chama <code>FATORIAL(3)</code></li>
            <li>... continua até <code>FATORIAL(0)</code>, que retorna <code>1</code></li>
        </ol>
        <p>Retornos subsequentes:</p>
        <ul>
            <li><code>FATORIAL(1)</code> retorna <code>1</code></li>
            <li><code>FATORIAL(2)</code> retorna <code>2 * 1 = 2</code></li>
            <li><code>FATORIAL(3)</code> retorna <code>3 * 2 = 6</code>, e assim por diante até <code>FATORIAL(5)</code> retornar <code>120</code>.</li>
        </ul>

        <h2>4. Considerações Finais sobre Recursividade</h2>
        <p>Recursividade permite escrever código mais conciso e abstrato. No entanto, deve ser utilizada com cautela devido ao consumo de recursos. Ela é ideal para problemas naturalmente recursivos, como cálculos de fatorial, sequência de Fibonacci, e problemas de busca em árvores.</p>
    </div>
</body>
</html>